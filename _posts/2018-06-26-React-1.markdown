---
layout: post
title:  "React eject"
date:   2018-06-26 18:48:00
author: 이상현
categories: React
---

# 리액트 16
리액트 16의 주요 기능들을 살펴보자.

# Fragment
```js
class ReturnTypes extends Component {
  render() {
    return (
        <fragment>
          <header>header</header>
          <div>div</div>
          <footer>footer</footer>
        <fragment/>
    )
  }
}
```
<pre>
렌더링을 할때에는 항상 span이나, div (주로 span)이 있어야 하거나,
배열의 형태로써 표현하여 바깥쪽에 모든 것을 감싸는 1개의 태그가 필요했다.
하지만 fragment를 이용하면 span을 사용할 때 처럼 별도의 태그를 만드는 것이 아니라,
아무 태그를 만들지 않으면서 감싸는 것이 가능하다.
</pre>

```js
class ReturnTypes extends Component {
  render() {
    return (
        <>
          <header>header</header>
          <div>div</div>
          <footer>footer</footer>
        </>
    )
  }
}
```
<pre>
 만약 웹팩으로 작업을 한다면 위와 같이 단순한 태그로도 fragment처럼 기능을 한다고 한다.
</pre>

# Return Types Strings
```js
class ReturnTypesExample extends Component {
  render() {
    return "return strings is possible";
  }
}

class FragmentExample extends Component {
  render() {
    return (
        <fragment>
          <header>header</header>
          <div>div</div>
          <footer>footer</footer>
          <ReturnTypesExample/>
        </fragment>
    )
  }
}
```
<pre>
	16이 되면서 이전에는 스트링을 리턴하는 컴포넌트에 대한 지원을 하지 않았던 것 같다.
	하지만 이제는 가능하다. 이거를 허용하는데 어떤 의미가 있는 지는 알아봐야 한다.
</pre>

# Portal
```js
<header>
	<h1>Cant touch this</h1>
	<span id="touchme"/>
</header>
<div id="root"></div>
```
<pre>
	위 처럼 리액트가 렌더링하는 루트 밖의 것을 조작하고 싶은 경우에 포탈을 사용한다.
</pre>

```js
import { createPortal } from "react-dom";

class PortalsExample extends Component {
  render() {
    return createPortal(
        <Message />,
        document.getElementById("touchme")
    )
  }
}

const Message = () => "Just touched it";
```
<pre>
	위 처럼하면 리액트가 렌더링하지 않는 부분에 접근하여 태그를 수정할 수 있다.

	포탈은 워드프레스 등과 같이 렌더링으로 접근 불가능한 곳의 수정에 용이하다.
</pre>

# Error Boundaries
```js
class ErrorMaker extends Component {
  state = {
    friends: ["a", "b", "c", "d"]
  }
  componentDidMount = () => {
    setTimeout(() => {
      this.setState({
        friends: undefined,
      })
    })
  }
  render(){
    const {friends} = this.state;
    return friends.map(friend => `${friend}`);
  }
}
```
<pre>
	위와 같이 에러를 발생시키는 녀석이 있다.
</pre>

```js
const ErrorCallback = () => " Sorry, something went wrong";

class App extends Component {
  state = {
    hasError: false,
  }

  componentDidCatch = (error, info) => {
    console.log(`catched ${error} the info i have is ${JSON.stringify(info)}`)
    this.setState({
      hasError: true,
    })
  }

  render() {
    return (
        <div className="App">
          <FragmentExample/>
          {this.state.hasError ? <ErrorCallback/> : <ErrorMaker/>}
        </div>
    );
  }
}
```
<pre>
	새로 생긴 라이프사이클인 componentDidCatch를 이용하여 에러를 관리할 수 있다.
	하지만 모든 컴포넌트를 관리하려고 했을때, 위와같이 모두 상태를 만들어주는 것은 비효율적인, 권장하지 않는 방법이다.
</pre>

# Error Boundaries with HOC(Higher Order Components)
```js
const BoundaryHOC = ProtectedComponent => class Boundary extends Component{
  state = {
    hasError: false
  }
  componentDidCatch = () => {
    this.setState({
      hasError: true,
    })
  }
  render() {
    const { hasError } = this.state;
    if (hasError) {
      return <ErrorFallback />
    }
    else {
      return <ProtectedComponent />
    }
  }
}
```
<pre>
	컴포넌트를 1개 받는 HOC 클래스를 만든다.
</pre>
```js
const PErrorMaker = BoundaryHOC(ErrorMaker)
const PPortalsExample = BoundaryHOC(PortalsExample)
const PReturnTypesExample = BoundaryHOC(ReturnTypesExample)
```
<pre>
	이후 보호하고 싶은 컴포넌트를 위와같이 하여 컴포넌트를 감싸는 컴포넌트를 생성한다.
</pre>

```js
export default BoundaryHOC(App);
```
<pre>
	만약 App을 보호하고 싶다면 App.js의 마지막을 위와같이 변경한다.
</pre>

# setState(null)
```js
import React, {Component} from 'react';

const MAX_PIZZAS = 20;

const eatPizza = (state, props) => {
  const {pizzas} = state;
  if (pizzas < MAX_PIZZAS) {
    return {
      pizzas: pizzas + 1
    }
  }
  else {
    return null;
  }
}

export default class SetStateNullExample extends Component {
  state = {
    pizzas: 0,
  }
  render() {
    const { pizzas } = this.state;
    return (
        <button onClick={this._handleClick}>{`I have eaten ${pizzas}`}</button>
    )
  }
  _handleClick = () => {
    this.setState(eatPizza);
  }
}
```
<pre>
	기존에는 더이상 state를 변경하고 싶지 않더라도 이전 state와 같은 값으로 setState를 해야했다.
	하지만 리액트16에서는 setState(null)을 통해 더이상 state를 업데이트 시키지 않으면서,
	기존에 있던 state도 보존할 수 있다.
</pre>
